pro parseobs, file, structre = out, tsys = tsys_out, itime = itime_out, $
              verbose = verbose
;+
; NAME:
;  PARSEOBS
; PURPOSE:
;  To parse a MIRIAD listobs chronology and return observational data to a
;  variable or a structure for analysis.
;
; CALLING SEQUENCE:
;  PARSEOBS, textfile [, structure = structure]
;
; INPUTS:
;  TEXTFILE -- A file generated by the MIRIAD listobs function.
;              Defaults to './listobs'
;
; KEYWORD PARAMETERS:
;  STRUCTURE -- set to contain the name of a variable which receive the
;               structure of observation information.
;               The tags include:
;               NAME -- The name of the object observed in each
;                       visibility set.
;               ITIME -- Integration time for each of the objects.
;               TIME -- The time (UT) of each observation.
;               DATE -- The date of the observation.
;               ANTS -- Names of the antennas used.
;               TSYS -- System temperature for each antenna in ANTS
;                       for each visibility set.
;               MEDIAN_TSYS -- Median system temperature over run.
;               OBJECT -- Array of Objects observed
;               TOTAL -- Total time corresponding (in order) to each
;                        of the elements in the OBJECT array in minutes.
;  VERBOSE -- Dump some results to screen.
; OUTPUTS:
;  Keyword mediated.
;  TSYS -- Store the median System Temperature in this variable.
;  ITIME -- Store a structure with Name tag being object name
;                   and Time tag being the Integration time total for
;                   that object.
; MODIFICATION HISTORY:
;       Written partially.
;       Fri Dec 20 14:01:57 2002, Erik Rosolowsky <eros@cosmic>
;
;-

  if n_elements(file) eq 0 then file = 'listobs'
  ff = findfile(file, count = ct)
  if ct eq 0 then begin
    message, 'File not found', /con
    return
  endif

  openr, lun, ff[0], /get
  file = ''
  tmp = ''
  endhere = 0B
  nl = numlines(ff[0])

  for ii = 0, nl-1 do begin
    readf, lun, tmp
    tmp = strmid(tmp, 0, 1000)
    file = [file, tmp]
  endfor
  close, lun
  free_lun, lun

  startind = where(stregex(file, 'Chronology', /bool), ct)
  if ct eq 0 then begin
    message, 'No Valid Observation Chronology', /con
  endif

  dateline = file[startind]
  date = stregex(dateline, '[0-9]{2}[A-Z]{3}[0-9]{2}', /extract)

  antsline = file[startind+2]
  text = strsplit(antsline, ' ', /ext)
  ants_inds = where(stregex(text, '[1-9]', /bool), ant_count)
  ants = text[ants_inds]

  delim_pos = where(stregex(file, '-{10}', /bool))
  next_ind = where(delim_pos gt startind[0]+2, delim_ct)
  if delim_ct eq 0 then begin
    message, 'No trailing delimiter', /con
    next_delim = nl-1
  endif else next_delim = delim_pos[next_ind]
  
  name = ''
  time = ''
  itime = 0.
  elev = 0.
  bw1 = 0.
  bw2 = 0.
  corrmode = 0
  tsys = fltarr(ant_count, next_delim[0]-3-startind[0])

  for jj = startind[0]+3, next_delim[0]-1 do begin
<<<<<<< parseobs.pro
    line = strsplit(file[jj], '\ ', /ext)
=======
    line = strsplit(file[jj], ' ', /ext)
>>>>>>> 1.3
    name = [name, line[0]]
    time = [time, line[1]]
    itime = [itime, float(line[2])]
    elev = [elev, float(line[3])]
    bw1 = [bw1, float(line[4])]
    bw2 = [bw2, float(line[5])]
    corrmode = [corrmode, fix(line[6])]
    tsys_string = line[7:*]
;Trap invalid Tsys measures
    bad_inds = where(stregex(tsys_string, '[^0-9]', /bool), bad_ct)
    if bad_ct gt 0 then tsys_string[bad_inds] = '-9999'
    ts = float(tsys_string)
    if bad_ct gt 0 then ts[bad_inds] = !values.f_nan
    tsys[*, jj-startind[0]-3] = ts
  endfor
;Prune of initial values
  name = name[1:*]
  time = time[1:*]
  itime = itime[1:*]
  elev = elev[1:*]
  bw1 = bw1[1:*]
  bw2 = bw2[1:*]
  corrmode = corrmode[1:*]

  freqline = stregex(file, 'Rest Freq:(\ *)([0-9,.])*', /extract)
  freqline_ind = where(freqline ne '', freq_ct)
  if freq_ct gt 0 then $
    freq = float(stregex(freqline[freqline_ind], '([0-9,.])+', /ext)) else $
    freq = !values.f_nan
  
  tsys_out = median(tsys[where(tsys eq tsys)])
; Calculate integration times for each object
  uniq_objs = name[uniq(name, sort(name))]
  total_time = fltarr(n_elements(uniq_objs)) 
  for i = 0, n_elements(uniq_objs)-1 do begin
    inds = where(name eq uniq_objs[i])
    total_time[i] = total(itime[inds])
  endfor
  itime_out = {name:uniq_objs, time:total_time}

; Build the output structure.
  out = {freq:freq, date:date[0], $
         name:name, itime:itime, time:time, $
         ants:ants, tsys:tsys, median_tsys:tsys_out, $
         object:uniq_objs, total:total_time}
  if keyword_set(verbose) then begin
    print, 'OBSERVATION ON '+date[0]+' AT '+strcompress(freq)
    print, 'Number of antennas in use: '+strcompress(n_elements(ants))
    print, 'Objects included:'
    for i = 0, n_elements(uniq_objs)-1 do begin
      print, strcompress(i+1, /rem), ': ', uniq_objs[i], ' -- ', $
        decimals(total_time[i]/60, 0), ' h ', $
        decimals(total_time[i] mod 60, 0), ' m'
    endfor
    print, 'Median System Temperature: ', strcompress(tsys_out)
  endif

  return
end
