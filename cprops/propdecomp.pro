function propdecomp, xin, yin, vin, tin, lmaxin, merger = merge_matrix $
                     , levels = clev, all_neighbors = all_neighbors
  

;+
;
; NAME:
;  PROPDECOMP
; PURPOSE:
;  To provide decomposition of a cloud with an input set of kernels
;  down to the level where clouds merge.  This routine only assigns
;  uncontested emission.
;
; CALLING SEQUENCE:
;  assignment = PROPDECOMP(x, y, v, t, kernels, merger = merger,
;  levels = levels)
;
; INPUTS:
;   X,Y,V,T -- Vectors of the position and amplitude of the data
;   KERNELS -- The positions of the local maximum in the input vectors
;   
; KEYWORD PARAMETERS:
;   MERGER -- A merge matrix generated by the MERGEFIND() function
;             (REQUIRED) 
;
; OUTPUTS:
;   ASSIGNMENT -- A vector containing a unique integer assignment for
;                 every unique cloud.  Note that cloud assignments
;                 begin with the value 2, with the value of 1 being
;                 reserved for watershed / contested emission. 
;
; MODIFICATION HISTORY:
;       Long and storied.
;
;	Fri Mar 24 11:36:43 2006, Erik 
;       Added all_neighbors keyword.       
;
;-

  if n_elements(clev) eq 0 then clev = contour_values(tin)

; EXTRAPOLATE TO ZERO KELVIN
  targett = 0.0

; DEFINE VALUES FOR THE OUTPUT ARRAY
  unassigned = 0
  contested  = 1

; DEFINE THE LEVEL OF A SIGNIFICANT DISCONTINUITY




; INITIALIZE THE OUTPUT ARRAY. ALL CLOUDS START OUT AS
; SHARED/CONTESTED/WATERSHED AMONG THE VARIOUS LOCAL MAXES.
  fragassign = lonarr(n_elements(xin)) + 1

  nlmaxin = n_elements(lmaxin) 
  cubify, xin, yin, vin, tin, cube = minicube, location = location, pad = 1

  lmax = lmaxin
  nlmax = n_elements(lmax) 
  kernels = location[lmax]
  for i = 0, nlmax-1 do begin
    this_kernel = location[lmax[i]]
    min_contour = minimergefind(minicube, this_kernel, $
                                kernels, levels = clev)
    regions = label_region(minicube gt min_contour, /ULONG, all_neighbors = all_neighbors)
    mask_index = where(regions)
    region_label = regions[mask_index[where(mask_index eq this_kernel)]]

    null = intersection(location, where(regions eq region_label[0]), $
                        /index_tag, a_index = ind)
    fragassign[ind] = i+2
  endfor

  return, fragassign
end                             ; OF PROPDECOMP
